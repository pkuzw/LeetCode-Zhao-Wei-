/* @brief

Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? 

Find all unique quadruplets in the array which gives the sum of target.

Note:
Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)

The solution set must not contain duplicate quadruplets.

For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
*/
///@author	zhaowei
///@date	2015.06.06
///@version 1.0

#include <iostream>
#include <vector>
#include <cstdlib>

using namespace std;

class Solution
{
public:
	///@brief	求4个数之和为指定值的所有组合
	///@param	nums	待处理的数组
	///@return	返回所有可能的组合，在每一个4元组答案中按照非降序排列元素
	///@author	zhaowei
	///@date	2015.06.06
	/* @note	先通过快速排序将原有数组排序，然后将其转换成不包括重复元素的数组，再然后就是通过二分查找找到4个数和为指定值的组合。
				时间复杂度为	O(nlgn+n^3lgn)，空间复杂度是O(3n) 
	*/
	vector<vector<int>> fourSum(vector<int>& nums, int target) {

		QuickSort(nums, 0, nums.size()-1);	// 快排

		vector<int> nr_nums;	// 将nums中重复出现的元素抽成只出现一次
		vector<int> rt_nums;	// 记录重复出现元素的个数数组
		int cnt = 1;			// 记录重复出现的元素个数

		vector<vector<int>> ivvec;	//三元组为元素组成的向量

		if (nums.empty())	//如果nums为空向量，直接返回空向量
		{
			return ivvec;
		}

		for (int i = 0; i < nums.size(); i++)	// 将原有数组转换成没有重复元素的数组
		{	
			// 因为i+1有可能越界，所以要单独拿出来判断。循环里的变量边界需要设成num.size()-1，这样不会漏掉最后一个数
			if (i < nums.size()-1 && nums[i] == nums[i+1])	
			{
				cnt++;
				continue;
			}
			nr_nums.push_back(nums[i]);
			rt_nums.push_back(cnt);
			cnt = 1;
		}
		
		int l = 0, r = nr_nums.size()-1;	

		int a = 0, b = 0, c = 0, d = 0;
		for (int i = 0; i <= r; i++)
		{				
			a = nr_nums[i];

			for (int j = i; j <= r; j++)	
			{								
				b = nr_nums[j];

				if (a == b && rt_nums[i] < 2)	// 如果没有两个重复元素，则跳过
				{
					continue;
				}

				for (int k = j; k <= r; k++)
				{
					vector<int> four_elem;
					c = nr_nums[k];
					if ((b == c && rt_nums[j] < 2) 
						|| (b == c && a == b && rt_nums[j] < 3))
					{
						continue;
					}
					d = target-a-b-c;
					int e = BinarySearch(nr_nums, k, r, d); // d的二分查找范围只能是在c的下标k和r之间
					
					if (e == -1
						|| (e == k && rt_nums[k] < 2)
						|| (e == k && c == b && rt_nums[k] < 3) 
						|| (e == k && c == b && b == a && rt_nums[k] < 4))
					{
						continue;
					}
					
					four_elem.push_back(a);
					four_elem.push_back(b);
					four_elem.push_back(c);
					four_elem.push_back(d);

					ivvec.push_back(four_elem);
				}			
			}				
		}
		return ivvec;
	}

	///@brief 交换两个整型变量
	///@param a, b 待交换的两个元素
	///@author zhaowei
	///@date 2014.07.15
	void swap(int& a, int& b)
	{
		int t = a;
		a = b;
		b = t;
		return;
	}

	///@brief	将数组分割，使其左半部分的元素都比返回值小，右半部分的元素都比返回值大。
	///@param	arr	数组指针
	///@param	p	起始下标
	///@param	r	终止下标
	///@return	返回分割后数组的中轴值
	///@author	zhaowei
	///@date	2014.07.15	
	int Partition(vector<int>& arr, const int p, const int r)
	{		
		int x = arr[r];
		int i = p-1;
		for(int j = p; j < r; j++)
		{
			if(arr[j] <= x)
			{
				i++;
				swap(arr[j], arr[i]);
			}		
		}
		swap(arr[i+1], arr[r]);
		return i+1;
	}

	///@brief	用递归实现快速排序
	///@param	arr	数组指针。这里应该是引用，否则无法进行递归
	///@param	p	数组起始下标
	///@param	r	数组终止下标
	///@author	zhaowei
	///@date	2014.07.15
	void QuickSort(vector<int>& arr, const int p, const int r)
	{
		if(p < r)
		{
			int q = Partition(arr, p, r);
			QuickSort(arr, p, q-1);
			QuickSort(arr, q+1, r);
		}
		return;
	}

	///@brief	二分查找函数
	///@param	&array_int	 排好序的数组，这里应该是引用，否则无法进行递归
	///@param	p			 数组的起始下标
	///@param	r	 数组的终止下标
	///@param	v	 待查找的值
	///@return	如果在数组中找到v值，则返回该值所在下标；否则返回-1
	int BinarySearch(vector<int>& array_int, int p, int r, int v)
	{
		if(p > r)/* || v < array_int[p] || v > array_int[r])*/
			return -1;
		int q = (p + r) / 2;
		if(v == array_int[q])
			return q;
		else if(v < array_int[q])
			BinarySearch(array_int, p, q-1, v);
		else 
			BinarySearch(array_int, q+1, r, v);
	}
};

int main()
{
	vector<int> ivec;	
	int n[201] = {91277418,66271374,38763793,4092006,11415077,60468277,1122637,72398035,-62267800,22082642,60359529,-16540633,92671879,-64462734,-55855043,-40899846,88007957,-57387813,-49552230,-96789394,18318594,-3246760,-44346548,-21370279,42493875,25185969,83216261,-70078020,-53687927,-76072023,-65863359,-61708176,-29175835,85675811,-80575807,-92211746,44755622,-23368379,23619674,-749263,-40707953,-68966953,72694581,-52328726,-78618474,40958224,-2921736,-55902268,-74278762,63342010,29076029,58781716,56045007,-67966567,-79405127,-45778231,-47167435,1586413,-58822903,-51277270,87348634,-86955956,-47418266,74884315,-36952674,-29067969,-98812826,-44893101,-22516153,-34522513,34091871,-79583480,47562301,6154068,87601405,-48859327,-2183204,17736781,31189878,-23814871,-35880166,39204002,93248899,-42067196,-49473145,-75235452,-61923200,64824322,-88505198,20903451,-80926102,56089387,-58094433,37743524,-71480010,-14975982,19473982,47085913,-90793462,-33520678,70775566,-76347995,-16091435,94700640,17183454,85735982,90399615,-86251609,-68167910,-95327478,90586275,-99524469,16999817,27815883,-88279865,53092631,75125438,44270568,-23129316,-846252,-59608044,90938699,80923976,3534451,6218186,41256179,-9165388,-11897463,92423776,-38991231,-6082654,92275443,74040861,77457712,-80549965,-42515693,69918944,-95198414,15677446,-52451179,-50111167,-23732840,39520751,-90474508,-27860023,65164540,26582346,-20183515,99018741,-2826130,-28461563,-24759460,-83828963,-1739800,71207113,26434787,52931083,-33111208,38314304,-29429107,-5567826,-5149750,9582750,85289753,75490866,-93202942,-85974081,7365682,-42953023,21825824,68329208,-87994788,3460985,18744871,-49724457,-12982362,-47800372,39958829,-95981751,-71017359,-18397211,27941418,-34699076,74174334,96928957,44328607,49293516,-39034828,5945763,-47046163,10986423,63478877,30677010,-21202664,-86235407,3164123,8956697,-9003909,-18929014,-73824245, -236727523};
	string s = "91277418,66271374,38763793,4092006,11415077,60468277,1122637,72398035,-62267800,22082642,60359529,-16540633,92671879,-64462734,-55855043,-40899846,88007957,-57387813,-49552230,-96789394,18318594,-3246760,-44346548,-21370279,42493875,25185969,83216261,-70078020,-53687927,-76072023,-65863359,-61708176,-29175835,85675811,-80575807,-92211746,44755622,-23368379,23619674,-749263,-40707953,-68966953,72694581,-52328726,-78618474,40958224,-2921736,-55902268,-74278762,63342010,29076029,58781716,56045007,-67966567,-79405127,-45778231,-47167435,1586413,-58822903,-51277270,87348634,-86955956,-47418266,74884315,-36952674,-29067969,-98812826,-44893101,-22516153,-34522513,34091871,-79583480,47562301,6154068,87601405,-48859327,-2183204,17736781,31189878,-23814871,-35880166,39204002,93248899,-42067196,-49473145,-75235452,-61923200,64824322,-88505198,20903451,-80926102,56089387,-58094433,37743524,-71480010,-14975982,19473982,47085913,-90793462,-33520678,70775566,-76347995,-16091435,94700640,17183454,85735982,90399615,-86251609,-68167910,-95327478,90586275,-99524469,16999817,27815883,-88279865,53092631,75125438,44270568,-23129316,-846252,-59608044,90938699,80923976,3534451,6218186,41256179,-9165388,-11897463,92423776,-38991231,-6082654,92275443,74040861,77457712,-80549965,-42515693,69918944,-95198414,15677446,-52451179,-50111167,-23732840,39520751,-90474508,-27860023,65164540,26582346,-20183515,99018741,-2826130,-28461563,-24759460,-83828963,-1739800,71207113,26434787,52931083,-33111208,38314304,-29429107,-5567826,-5149750,9582750,85289753,75490866,-93202942,-85974081,7365682,-42953023,21825824,68329208,-87994788,3460985,18744871,-49724457,-12982362,-47800372,39958829,-95981751,-71017359,-18397211,27941418,-34699076,74174334,96928957,44328607,49293516,-39034828,5945763,-47046163,10986423,63478877,30677010,-21202664,-86235407,3164123,8956697,-9003909,-18929014,-73824245, -236727523";
 	
 	int cnt = 0;
 	for (int i = 0; i < s.length(); i++)
 	{
 		if (s[i] == ',')
 		{
 			cnt ++;
 		}
 	}
// 	cout << cnt << endl;
 	for (int i = 0; i < 6; i++)
 	{
 		ivec.push_back(n[i]);
 	}
 	
	vector<int> ivec2;
	ivec2.push_back(0);
	ivec2.push_back(0);
	ivec2.push_back(0);
	ivec2.push_back(0);

	vector<int> ivec3;

	Solution slt;
	vector<vector<int>> ivvec;
	ivvec = slt.fourSum(ivec, 2);
	for (int i = 0; i < ivvec.size(); i++)
	{
		for (int j = 0; j < ivvec[i].size(); j++)
		{
			cout << ivvec[i][j] << ' ';
		}
		cout << endl;
	}
	return 0;
}